lines(reg8$fitted.values, col=8)
reg9 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4))
summary(reg9)
lines(reg9$fitted.values, col=9)
reg10 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4)+I(tt^5))
summary(reg10)
lines(reg9$fitted.values, col=10)
reg11 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4)+I(tt^5)+I(tt^6))
summary(reg11)
lines(reg9$fitted.values, col=11)
reg12 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4)+I(tt^5)+I(tt^6)+I(tt^7)+I(tt^8))
summary(reg12)
lines(reg9$fitted.values, col=12)
lts = log(timeseries)
reg6 = lm(lts~tt)
summary(reg6)
plot(tt, lts) # 근데 우리는 ts plot()에 덮어 그릴수는 없음.
lines(reg6$fitted.values, col=6)
reg7 = lm(lts~tt+I(tt^2))
summary(reg7)
lines(reg7$fitted.values, col=7)
reg8 = lm(lts~tt+I(tt^2)+I(tt^3))
summary(reg8)
lines(reg8$fitted.values, col=8)
reg9 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4))
summary(reg9)
lines(reg9$fitted.values, col=9)
reg10 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4)+I(tt^5))
summary(reg10)
lines(reg9$fitted.values, col=10)
reg11 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4)+I(tt^5)+I(tt^6))
summary(reg11)
lines(reg9$fitted.values, col=11)
reg12 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4)+I(tt^5)+I(tt^6)+I(tt^7))
summary(reg12)
lines(reg12$fitted.values, col=12)
reg13 = lm(lts~tt+I(tt^2)+I(tt^3)+I(tt^4)+I(tt^5)+I(tt^6)+I(tt^7)+I(tt^8))
summary(reg13) # 8차항은 오버라는것을 알 수 있다.
# 여기서 이제 우리는 분기별 데이터도 적용이 되게 해보자.
m1 <- (tt%%12)==1; m2 <- (tt%%12)==2; m3 <- (tt%%12)==3
m4 <- (tt%%12)==4; m5 <- (tt%%12)==5; m6 <- (tt%%12)==6
m7 <- (tt%%12)==7; m8 <- (tt%%12)==8; m9 <- (tt%%12)==9
m10 <- (tt%%12)==10; m11 <- (tt%%12)==11 # 12월은 자유도.
reg14 = lm(timeseries~tt+m1+m2+m3+m4+m5+m6+m7+m8+m9+m10+m11)
summary(reg14)
plot(tt, lts) # 근데 우리는 ts plot()에 덮어 그릴수는 없음.
lines(reg14$fitted.values, col=14)
# 여기서 이제 우리는 분기별 데이터도 적용이 되게 해보자.
m1 <- (tt%%12)==1; m2 <- (tt%%12)==2; m3 <- (tt%%12)==3
m4 <- (tt%%12)==4; m5 <- (tt%%12)==5; m6 <- (tt%%12)==6
m7 <- (tt%%12)==7; m8 <- (tt%%12)==8; m9 <- (tt%%12)==9
m10 <- (tt%%12)==10; m11 <- (tt%%12)==11 # 12월은 자유도.
reg14 = lm(timeseries~tt+m1+m2+m3+m4+m5+m6+m7+m8+m9+m10+m11)
summary(reg14)
rsq(reg1)
library(rsq)
install.packages('rsq')
rsq(reg1)
library(rsq)
rsq(reg1)
apply(modelselection, rsq)
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
apply(modelselection,2,rsq)
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
apply(modelselection,1,rsq)
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
apply(modelselection, 1, rsq)
dim(modelselection)
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
lapply(modelselection, 1, rsq)
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
lapply(modelselection, rsq)
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
lapply(modelselection, rsq)
str(modelselection)
rsq(reg1)
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
for (i in modelselection) {
print(rsq(i), end = '\t')
}
modelselection = c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
for (i in modelselection) {
print(i)
}
modelselection = list(c(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11))
for (i in modelselection) {
print(i)
}
list()
list(reg1,reg2,reg3)
modelselection = list(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
for (i in modelselection) {
print(i)
}
modelselection = list(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
lapply(modelselection, rsq)
modelselection = list(reg1,reg2,reg3,reg4,reg6,reg7,reg8,reg9,reg10,reg11)
library(rsq)
rsquare = lapply(modelselection, rsq)
print(rsquare)
print(sum((timeseries-reg1$fitted.values)^2))
print(sum((timeseries-reg2$fitted.values)^2))
print(sum((timeseries-reg3$fitted.values)^2))
print(sum((timeseries-reg4$fitted.values)^2))
print(sum((timeseries-exp(reg6$fitted.values))^2))
print(sum((timeseries-exp(reg7$fitted.values))^2))
print(sum((timeseries-exp(reg8$fitted.values))^2))
print(sum((timeseries-exp(reg9$fitted.values))^2))
print(sum((timeseries-exp(reg10$fitted.values))^2))
print(sum((timeseries-exp(reg11$fitted.values))^2))
path = C:\Users\styli\Desktop\동아리 프로젝트 3coronavirusdataset_20200430\Case.csv
path = 'C:\Users\styli\Desktop\동아리 프로젝트 3coronavirusdataset_20200430\Case.csv'
dirname(path)
choose.files()
#### libaray IMPORT ####
library(TTR)      # calc function for sma
library(forecast) # calc function for ma
ma.4 = ma(timeseries, order=4, centre = TRUE)
setwd('E:/오늘할거/4-1학기/시계열')
library(data.table)
data = fread('ECOS_TABLE_20220313_162202.csv', skip=3, nrow=264, header=T)
names(data) = c('기준일', 'KOSPI지수')
head(data)
data$KOSPI지수 = gsub(",", "", data$KOSPI지)
data$KOSPI지수 = as.numeric(data$KOSPI지수)
str(data)
timeseries = ts(data = data$KOSPI지수, start = c(2000,2), frequency = 12)
timeseries
#### libaray IMPORT ####
library(TTR)      # calc function for sma
library(forecast) # calc function for ma
ma.4 = ma(timeseries, order=4, centre = TRUE)
plot(timeseries); lines(ma.4, col = 2)
#### libaray IMPORT ####
library(TTR)      # calc function for sma
library(forecast) # calc function for ma
ma.12 = ma(timeseries, order=12, centre = TRUE)
plot(timeseries); lines(ma.4, col = 2)
#### libaray IMPORT ####
library(TTR)      # calc function for sma
library(forecast) # calc function for ma
ma.12 = ma(timeseries, order=12, centre = TRUE)
plot(timeseries); lines(ma.12, col = 2)
#### libaray IMPORT ####
library(TTR)      # calc function for sma
library(forecast) # calc function for ma
# 분기별 데이터인 4와
ma.4 = ma(timeseries, order=4, centre = TRUE)
ma.12 = ma(timeseries, order=12, centre = TRUE)
plot(timeseries); lines(ma.4, col = 2); lines(ma.12, col = 3)
lowess(data, f = 2/3) # f = 가중치값(공부할때 0-1사이 값이라 했음, 클때 작을때 영향 뭐게?)
lowess(data, f = 2/3)
plot(timeseries); plot(lowess(timeseries, f = 2/3)$y, col=2)
plot(timeseries); lines(lowess(timeseries, f = 2/3)$y, col=2)
plot(data); lines(lowess(timeseries, f = 2/3)$y, col=2)
t = 1:length(data)
t = 1:length(data)
plot(t, data); lines(lowess(timeseries, f = 2/3)$y, col=2)
t = 1:length(data)
print(t); str(t)
#plot(t, data); lines(lowess(timeseries, f = 2/3)$y, col=2)
data
t = 1:nrow(data)
print(t); str(t)
#plot(t, data); lines(lowess(timeseries, f = 2/3)$y, col=2)
t = 1:nrow(data)
plot(t, data); lines(lowess(timeseries, f = 2/3)$y, col=2)
data
str(dat)
str(data)
dim(data)
plot(t, data[,2])
data[,2]
plot(t, data$KOSPI지수)
plot(t, data$KOSPI지수, type='l')
t = 1:nrow(data)
plot(t, data$KOSPI지수, type='l'); lines(lowess(timeseries, f = 2/3)$y, col=2)
#
2/3
1/2
2/9
3/11
1/6
1/7
t = 1:nrow(data)
plot(t, data$KOSPI지수, type='l');
lines(lowess(timeseries, f = 2/3)$y, col=2)
lines(lowess(timeseries, f = 1/2)$y, col=3)
lines(lowess(timeseries, f = 3/11)$y, col=4)
lines(lowess(timeseries, f = 1/7)$y, col=5)
t = 1:nrow(data)
plot(t, data$KOSPI지수, type='l');
lines(lowess(timeseries, f = 2/3)$y, col=2) # 빨
lines(lowess(timeseries, f = 1/2)$y, col=3) # 초
lines(lowess(timeseries, f = 3/11)$y, col=4) # 파
lines(lowess(timeseries, f = 1/7)$y, col=5) # 하늘
lines(lowess(timeseries, f = 1/10)$y, col=6) # 하늘
m.vec = 2:20 # grid Search parameter
mse.vec = c()
for(m in m.vec){
sma.m = c(NA, SMA(timeseries, n=m))
end = length(sma.m)
mse = mean((timeseries-sma.m[-end])^2, na.rm=TRUE)
mse.vec = c(mse.vec, mse)
}
print(m.vec[which.min(mse.vec)])
m.vec = 3:20 # grid Search parameter
mse.vec = c()
for(m in m.vec){
sma.m = c(NA, SMA(timeseries, n=m))
end = length(sma.m)
mse = mean((timeseries-sma.m[-end])^2, na.rm=TRUE)
mse.vec = c(mse.vec, mse)
}
print(m.vec[which.min(mse.vec)])
m.vec = 4:20 # grid Search parameter
mse.vec = c()
for(m in m.vec){
sma.m = c(NA, SMA(timeseries, n=m))
end = length(sma.m)
mse = mean((timeseries-sma.m[-end])^2, na.rm=TRUE)
mse.vec = c(mse.vec, mse)
}
print(m.vec[which.min(mse.vec)])
m.vec = 2:20 # grid Search parameter
mse.vec = c()
for(m in m.vec){
sma.m = c(NA, SMA(timeseries, n=m))
end = length(sma.m)
mse = mean((timeseries-sma.m[-end])^2, na.rm=TRUE)
mse.vec = c(mse.vec, mse)
}
print(mse.vec)
print(m.vec[which.min(mse.vec)])
sma.4 = SMA(timeseries, n=4)
tail(sma.4) # 데이터의 형태를 보니, 아님 plot결과를 보니 국소적 선형모형이 올바르지 않을까 생각가능.
# 단순 이동평균 구한 값을, 다시 이동평균 구하는 방법.
dma.4 = SMA(sma.4, n = 4)
dma.4
# 공식에 대입 - ppt 17~20p내용.
n = length(data)
ma.trend = c(NA, (2*sma.4 - dma.4) + (2/3)*(sma.4-dma.4), (2*sma.4[n]-dma.4[n]) + (2/3)*(sma.4[n]-dma.4[n])*(2:23))
# 이거 이해 못했음...;;;;
n
# 공식에 대입 - ppt 17~20p내용.
n = nrow(data)
sma.4 = SMA(timeseries, n=4)
tail(sma.4) # 데이터의 형태를 보니, 아님 plot결과를 보니 국소적 선형모형이 올바르지 않을까 생각가능.
# 단순 이동평균 구한 값을, 다시 이동평균 구하는 방법.
dma.4 = SMA(sma.4, n = 4)
dma.4
# 공식에 대입 - ppt 17~20p내용.
n = nrow(data)
ma.trend = c(NA, (2*sma.4 - dma.4) + (2/3)*(sma.4-dma.4), (2*sma.4[n]-dma.4[n]) + (2/3)*(sma.4[n]-dma.4[n])*(2:23))
t
# 이거 이해 못했음...;;;;
plot(t, data$KOSPI지수); plot(t, ma.trend)
t
# 선형 이동 평균법을 사용해보자. (SMA에서 나온 공식)
sma.4 = SMA(timeseries, n=4)
tail(sma.4) # 데이터의 형태를 보니, 아님 plot결과를 보니 국소적 선형모형이 올바르지 않을까 생각가능.
# 단순 이동평균 구한 값을, 다시 이동평균 구하는 방법.
dma.4 = SMA(sma.4, n = 4)
dma.4
# 공식에 대입 - ppt 17~20p내용.
n = nrow(data)
ma.trend = c(NA, (2*sma.4 - dma.4) + (2/3)*(sma.4-dma.4), (2*sma.4[n]-dma.4[n]) + (2/3)*(sma.4[n]-dma.4[n])*(2:23))
plot(t, data$KOSPI지수, type='l')# ; plot(t, ma.trend)
# 선형 이동 평균법을 사용해보자. (SMA에서 나온 공식)
sma.4 = SMA(timeseries, n=4)
# 단순 이동평균 구한 값을, 다시 이동평균 구하는 방법.
dma.4 = SMA(sma.4, n = 4)
# 공식에 대입 - ppt 17~20p내용.
n = nrow(data)
ma.trend = c(NA, (2*sma.4 - dma.4) + (2/3)*(sma.4-dma.4), (2*sma.4[n]-dma.4[n]) + (2/3)*(sma.4[n]-dma.4[n])*(2:23))
plot(t, data$KOSPI지수, type='l'); lines(t, ma.trend, col=2)
ma.trend
length(ma.trend)
length(t)
plot(t, data$KOSPI지수, type='l'); lines(ma.trend, col=2)
es = HoltWinters(timeseries) # alpha, beta, gamma는 자동으로 연산을 시킨다. 고정X
plot(es)
es = HoltWinters(timeseries) # alpha, beta, gamma는 자동으로 연산을 시킨다. 고정X
plot(es)
forecast(es)
plot(forecast(es))
es = HoltWinters(timeseries) # alpha, beta, gamma는 자동으로 연산을 시킨다. 고정X
plot(es)
plot(forecast(es))
# 선형 이동 평균법을 사용해보자. (SMA에서 나온 공식)
# n은 최적 선정인 2로 결정하였다.
sma = SMA(timeseries, n=2)
# 단순 이동평균 구한 값을, 다시 이동평균 구하는 방법.
dma = SMA(sma, n = 2)
# 공식에 대입 - ppt 17~20p내용.
n = nrow(data)
ma.trend = c(NA, (2*sma - dma) + (2/3)*(sma-dma), (2*sma[n]-dma[n]) + (2/3)*(sma[n]-dma[n])*(2:23))
plot(t, data$KOSPI지수, type='l'); lines(ma.trend, col=2)
co2
# 이 코드를 바꿔야함.
co2.fore <- c(co2, rep(NA,24))
co2.fore
fore.ts <- ts(co2.fore, start=c(1959,1), frequency=12)
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(timeseries, start=c(1959,1), frequency=12)
str(fore.ts)
fore.ts
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
timeseries
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
fore.ts
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(co2.fore.ts)
abline(v=1998, col="red", lty=2)
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
abline(v=1998, col="red", lty=2)
plot(fore.ts)
abline(v=1998, col="red", lty=2)
fore.ts
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
abline(v=2020, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
abline(h=mean(co2), col="green")
lines(sma.fore.ts, col="blue")
sma.12 <- SMA(timeseries, n=12)
sma.12
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
sma.fore.ts
abline(h=mean(co2), col="green")
abline(v=2020, col="red", lty=2)
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
#abline(v=2020, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
#abline(v=2020, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
abline(h=mean(timeseries), col="green")
lines(sma.fore.ts, col="blue")
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
abline(v=2020, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
abline(h=mean(timeseries), col="green")
lines(sma.fore.ts, col="blue")
timeseries
# 이 코드를 바꿔야함.
fore <- c(timeseries, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
abline(v=2022, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
abline(h=mean(timeseries), col="green")
lines(sma.fore.ts, col="blue")
# 이 코드를 바꿔야함.
fore <- c(data$KOSPI지수, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
abline(v=2022, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
abline(h=mean(timeseries), col="green")
lines(sma.fore.ts, col="blue")
setwd('E:/오늘할거/4-1학기/시계열')
library(data.table)
data = fread('ECOS_TABLE_20220313_162202.csv', skip=3, nrow=264, header=T)
names(data) = c('기준일', 'KOSPI지수')
head(data)
data$KOSPI지수 = gsub(",", "", data$KOSPI지)
data$KOSPI지수 = as.numeric(data$KOSPI지수)
str(data)
timeseries = ts(data = data$KOSPI지수, start = c(2000,2), frequency = 12)
timeseries
#### libaray IMPORT ####
library(TTR)      # calc function for sma
library(forecast) # calc function for ma
# 분기별 데이터인 4와
ma.4 = ma(timeseries, order=4, centre = TRUE)
ma.12 = ma(timeseries, order=12, centre = TRUE)
plot(timeseries); lines(ma.4, col = 2); lines(ma.12, col = 3)
t = 1:nrow(data)
plot(t, data$KOSPI지수, type='l');
lines(lowess(timeseries, f = 2/3)$y, col=2) # 빨
lines(lowess(timeseries, f = 1/2)$y, col=3) # 초
lines(lowess(timeseries, f = 3/11)$y, col=4) # 파
lines(lowess(timeseries, f = 1/7)$y, col=5) # 하늘
lines(lowess(timeseries, f = 1/10)$y, col=6) # 보라
m.vec = 2:20 # grid Search parameter
mse.vec = c()
for(m in m.vec){
sma.m = c(NA, SMA(timeseries, n=m))
end = length(sma.m)
mse = mean((timeseries-sma.m[-end])^2, na.rm=TRUE)
mse.vec = c(mse.vec, mse)
}
print(mse.vec)
print(m.vec[which.min(mse.vec)])
# 이 코드를 바꿔야함.
fore <- c(data$KOSPI지수, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
plot(fore.ts)
abline(v=2022, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
# 이 코드를 바꿔야함.
fore <- c(data$KOSPI지수, rep(NA,24)) # 미래 24개 NA만듬
fore.ts <- ts(fore, start=c(2000,2), frequency=12)
n = nrow(data)
plot(fore.ts)
abline(v=2022, col="red", lty=2)
sma.12 <- SMA(timeseries, n=12)
sma.fore.ts <- ts(c(NA, sma.12, rep(sma.12[n],23)), start=c(2000,2), frequency=12)
abline(h=mean(timeseries), col="green")
lines(sma.fore.ts, col="blue")
es = HoltWinters(timeseries) # alpha, beta, gamma는 자동으로 연산을 시킨다. 고정X
plot(es)
plot(forecast(es))
# 선형 이동 평균법을 사용해보자. (SMA에서 나온 공식)
# n은 최적 선정인 2로 결정하였다.
sma = SMA(timeseries, n=2)
# 단순 이동평균 구한 값을, 다시 이동평균 구하는 방법.
dma = SMA(sma, n = 2)
# 공식에 대입 - ppt 17~20p내용.
n = nrow(data)
ma.trend = c(NA, (2*sma - dma) + (2/3)*(sma-dma), (2*sma[n]-dma[n]) + (2/3)*(sma[n]-dma[n])*(2:23))
plot(t, data$KOSPI지수, type='l'); lines(ma.trend, col=2)
Titanic
Titanic$
str(Titanic)
shapiro.test(iris$Sepal.Length)
qqplot(iris$Sepal.Length)
qqplot(iris$Sepal.Length, rnorm(150))
?qqplot
qqplot(iris$Sepal.Length, rnorm(150))
qqline(rnorm(150))
qqplot(iris$Sepal.Length, rnorm(150))
qqline(rnorm(150))
qqplot(iris$Sepal.Length, rnorm(150))
qqline(rnorm(150))
qqline(rnorm(150))
qqplot(iris$Sepal.Length, rnorm(150))
qqplot(iris$Sepal.Length, rnorm(150))
shapiro.test(iris$Sepal.Length)
qqplot(iris$Sepal.Length, rnorm(150))
shapiro.test(iris$Petal.Width)
qqplot(iris$Petal.Width, rnorm(150))
shapiro.test(iris$Petal.Length)
qqplot(iris$Petal.Length, rnorm(150))
shapiro.test(iris$Petal.Length)
qqplot(iris$Petal.Length, rnorm(150))
shapiro.test(iris$Sepal.Width)
qqplot(iris$Sepal.Width, rnorm(150))
shapiro.test(iris$Sepal.Width)
qqplot(iris$Sepal.Width, rnorm(150))
shapiro.test(iris$Sepal.Length)
qqplot(iris$Sepal.Length, rnorm(150))
shapiro.test(iris$Species)
iris$Species = factor(iris$Species)
shapiro.test(iris$Species)
qqplot(iris$Species, rnorm(150))
shapiro.test(iris$Species)
qqplot(iris$Species, rnorm(150))
shapiro.test(iris$Sepal.Length)
qqplot(iris$Sepal.Length, rnorm(150))
shapiro.test(iris$Sepal.Width)
qqplot(iris$Sepal.Width, rnorm(150))
shapiro.test(iris$Petal.Length)
qqplot(iris$Petal.Length, rnorm(150))
shapiro.test(iris$Petal.Width)
qqplot(iris$Petal.Width, rnorm(150))
library(data.table)
setwd('E:/[03] 단기 작업/동아리 7월 pj 산림/신규주제 분석/2022년/카드데이터')
data = fread('NATIVE(2018.1_2022.4).csv', sep="|", encoding="UTF-8")
data = read.table('NATIVE(2018.1_2022.4).txt', sep="|", encoding="cp949")
# 범주형 변수 군집화로 제천에 있는 유저들 특징 파악해보기? < 이번주 목표를 이걸로 해보자.
# 범주는 가변수 변환후 군집화 진행해야함.
# 성별/연령대/이용연월/요일/이용시간대/이용건수/취급액/업종 소분류/회원 거주지(17시도) 이걸 다넣어?
# 연령-성별로 군집분석하면, 어느 연령-성별대끼리 오는지 묶이겠지. > 고객 분석.
# 다변수니까 이건 LDA 해야할듯 아님 QDA
library(dplyr)
table(data$v3)
jc_data = data %>% filter(v3 == '제천시')
1/30
getwd()
fwrite('제천시 구매내역 데이터.csv', encoding = 'utf-8')
?fwrite
fwrite('제천시 구매내역 데이터.csv')
fwrite(jc_data, '제천시 구매내역 데이터.csv')
